---
title: Keel plugin
sidebar:
  order: 2
  hidden: true
---

import Install from "shared/src/Components/Install/Install.astro"

[Keel](https://www.keel.so) pairs especially well with Legend-State because it's designed for strong typing and developer experience, and because they've worked with us to make Legend-State and Keel pair perfectly together. All you need to do is provide the actions in the generated `keelClient.ts` and the observables will be fully typed and handle calling the correct action functions for you.

As a basic example, if you have a Keel model that that looks like this:

```
model Profile {
    fields {
        name Text
    }

    actions {
        get getProfile()
        create createProfile() with (name)
        update updateProfile(id) with (name)
        delete deleteProfile(id)
    }
}
```

Then you can pass the functions from the generated keelClient.ts into `syncedKeel` to create a fully typed observable:

```ts
import { observable } from '@legendapp/state'
import { syncedKeel } from '@legendapp/state/sync-plugins/keel'
const { mutations, queries } = client.api

const profile$ = observable(syncedKeel({
    get: queries.getProfile,
    create: mutations.createProfile,
    update: mutations.updateProfile,
    delete: mutations.deleteProfile,
}))
```

Then you can just get and modify the observable to two-way sync your data with Keel.

## Full Example

We'll start with a full example to see what a full setup looks like, then go into specific details.

```ts
import { observable } from '@legendapp/state'
import { configureSyncedKeel, syncedKeel } from '@legendapp/state/sync-plugins/keel'
import { APIClient } from './keelClient'
import ksuid from 'ksuid'

const client = new APIClient({
  baseUrl: process.env.API_BASE_URL, // http://localhost:8000/api
})

// a function to generateId locally
function generateId() {
    return ksuid.randomSync().string
}

// configure client and generateId
configureSyncedKeel({
    client,
    generateId,
})

// enable sync after authentication succeeds
async function doAuth() {
    // authenticate the client
    await keel.auth.authenticateWithPassword(email, pass)

    // check that the client is authenticated
    const isAuthenticated = await keel.auth.isAuthenticated()

    // enable syncedKeel to start syncing it
    configureSyncedKeel({
        enabled: true
    })
}

// Set up your observables with Keel queries
const { mutations, queries } = client.api

// create an observable with the action functions
const profile$ = observable(syncedKeel({
    get: queries.getProfile,
    create: mutations.createProfile,
    update: mutations.updateProfile,
    delete: mutations.deleteProfile,
    persist: { name: 'profile' },
}))
// get() activates and starts syncing
const profile = profile$.get()
```

## Configure globals

The first step to using the Keel plugin is to set some global configuration options. The required options are:

- **client**: It needs the client in order to set enable the keel realtime plugins.
- **generateId**: In order to create new rows locally the plugin needs to generate an ID locally. Keel uses `ksuid` for their IDs, so we suggest using that for best compatibility.
- **enabled**: Set enabled to true after you've [authenticated](https://docs.keel.so/apis/client#authenticating) with Keel. You can set this option separately whenever it's ready.

This is what a basic configuration should look like. You'll want to configure the options before using `syncedKeel`, and update `enabled` after you've [authenticated](https://docs.keel.so/apis/client#authenticating).


<Install name="ksuid" />

```ts
import { observable } from '@legendapp/state'
import { configureSyncedKeel, syncedKeel } from '@legendapp/state/sync-plugins/keel'
import { APIClient } from './keelClient'
import ksuid from 'ksuid'

const client = new APIClient({
  baseUrl: process.env.API_BASE_URL,
})

// configure client and generateId
configureSyncedKeel({
    client,
    generateId: () => ksuid.randomSync().string,
})

// enable sync after authentication succeeds
async function doAuth() {
    // authenticate the client
    await keel.auth.authenticateWithPassword(email, pass)

    // check that the client is authenticated
    const isAuthenticated = await keel.auth.isAuthenticated()

    // enable syncedKeel to start syncing it
    configureSyncedKeel({
        enabled: true
    })
}
```

TODO: Other config options

## get and list

The Keel plugin has two slightly different patterns depending on whether you're using a `get` or a `list` action.

The behavior when using `get` or `as: 'first'` is:
- **get**: Observable value is the value returned from get
- **create**: If get returned null, then setting any value on the observable will create
- **update**: If get returned a value, then updating any value on the observable will update
- **create**: Setting the value to null or undefined, or calling `delete()`, will delete

```ts
const { mutations, queries } = client.api

const profile$ = observable(syncedKeel({
    get: queries.getProfile,
    create: mutations.createProfile,
    update: mutations.updateProfile,
    delete: mutations.deleteProfile,
}))
// profile$.get() is a Profile
```

The behavior when using `list` is:
- **get**: Observable value is an object containing the listed values keyed by id
- **create**: Adding a new value to the object will will create with that value
- **update**: Updating a value in the object will update with the changed fields
- **create**: Setting the value to null or undefined, or calling `delete()`, will delete

Using `list` will create an observable with an object containing the listed values keyed by id. Updating existing values in the object will call the `update` function, adding new values will call the `create` function, and deleting keys will call the `delete` funtion.

```ts
const { mutations, queries } = client.api

const profiles$ = observable(syncedKeel({
    list: queries.listProfiles,
    create: mutations.createProfile,
    update: mutations.updateProfile,
    delete: mutations.deleteProfile,
}))
// profile$.get() is a Record<string, Profile>
```

The shape of the observable object can be changed with the `as` parameter, which supports three options:

1. `object`: The default, an object keyed by the row's `id` field.
2. `Map`: A Map, which can be more efficient for accessing rows by key
3. `first`: Treat the first result of a query like a `get`

Note that `array` is not an option because arrays make it hard to to efficiently and correctly add, update, and remove elements by id.

## where

When using a `list` function you may want to provide more options to the `where` query. You can do that by [customizing actions](#customizing-actions), but it is most easily done with the `where` parameter because the plugin may add its own `where` parameter when using `changesSince: 'last-sync'`.

In this example of using a [lookup table](TODO) by room, we can pass the `roomId` into the query:

```ts
const { mutations, queries } = client.api

const messages$ = observable({
    room: (roomId: string) =>
        syncedKeel({
            list: queries.listMessages,
            where: { roomId }
        })
})
// profile$.get() is a Record<string, Profile>
```

## Action functions

Using Legend-State with Keel puts two requirements on your model structure:

##### 1. id parameter in create actions

Because we generate ids locally, id needs to be include in create functions in your Keel models. You can make it optional if you may sometimes not give it an id.

##### 2. Include all possibly changeable fields as optional in create/update actions

This plugin sends updates with only the changed fields, so having some fields as required in update could cause the update action to fail. And if it changes any field which is not included in the action, that will also fail.

Additionally, using the debounceSet option may result in extra fields being set after it's initially created and before it sends the create action.

So we suggest:
- **create** actions should have required fields required and include all other fields as optional
- **update** actions should include all changeable fields as optional

##### 3. Include updatedAt? in list actions for changesSince: 'last-sync'

See [sync only diffs](#sync-only-diffs).

##### Example model structure

```
model Message {
    fields {
        // Cannot change after create
        user User
        // Changeable
        text Text
        status Boolean?
    }
    actions {
        list listUsers(updatedAt?)
        create createUser() with (id?, user.id, name, status?)
        create updateUser(id) with (name?, status?)
        delete deleteUser(id)
    }
}
```

## Customizing actions

In the previous examples we provided the keel function directly, but you can also provide your own function which calls the keel action. That can be useful for adding extra query or creation options, such as with a [lookup table](TODO).

```ts
import { mutations, queries, CreateProfileInput } from './keelClient'

const profiles$ = observable({
    user: (userId: string) =>
        syncedKeel({
            get: () => queries.getProfile({ userId }),
            create: (data: CreateProfileInput) =>
                mutations.createProfile({ user: { id: staffId }, ...data }),
            update: mutations.updateProfile,
            delete: mutations.deleteProfile,
        })
})
```

## Sync only diffs

An optional but very useful feature is the `changesSince: 'last-sync'` option. This can massively reduce badwidth usage when you're persisting list results since it only needs to list changes since the last query. The way this works internally is basically:

1. Save the maximum updatedAt to the local persistence
2. In subsquent syncs or after refresh it will list by `updatedAt: lastSync + 1` to get only recent changes
3. The new changes will be merged into the observable

To enable this on the Keel side, just include `updatedAt?` in the list parameters to enable querying by updatedAt.

```
model Message {
    ...
    actions {
        list listMessages(updatedAt?)
    }
}
```

And to enable this feature in Legend-State, use the `changesSince` option in combination with `list`. It can not work with get, but you can emulate a get with a list by creating a `list` action with an `id` parameter and the `as: 'first'` option in `syncedKeel`.


```ts
// Sync diffs of a list
syncedKeel({
    list: queries.listMessages,
    changesSince: 'last-sync',
    persist: {
        name: 'messages'
    }
})
// Sync diffs of a single value
syncedKeel({
    list: queries.listUserById,
    where: { id: myId },
    changesSince: 'last-sync',
    persist: {
        name: 'me'
    }
})
```

## Soft deletes

The delete parameter does not need to be an actual `delete` action in Keel. You could also implement it as a soft delete if you prefer, just setting a `deleted` field to true. To do that you could set up your Keel model like this:

```
model User {
    fields {
        deleted Boolean
    }

    actions {
        list listUsers() {
            @where(user.deleted != true)
        }
        update deleteUser(id) {
            @set(user.deleted = true)
        }
    }
}
```

## Usage

#### Add new element to table with id

To add a new element to an observable and use it locally before it has been created remotely, you can create it with a local id, and then it will be updated with `createdAt` and `updatedAt` after it's created in Keel.

Note that since `createdAt` and `updatedAt` are defined as required in the types they should to be set to undefined when creating.

```ts
import ksuid from 'ksuid'
import { Message } from './keelClient'

// a function to generateId locally
function generateId() {
    return ksuid.randomSync().string
}

const profile$ = observable(syncedKeel({
    get: queries.getProfile,
    create: mutations.createProfile,
    update: mutations.updateProfile,
    delete: mutations.deleteProfile,
}))

function addMessage(text: string) {
    const id = generateId()
    // Add keyed by id to the messages$ observable
    messages$[id].set({
        id,
        text,
        createdAt: undefined,
        updatedAt: undefined
    })
}
addMessage('test')
```

#### Wait for remote load

Because Keel automatically adds a `createdAt` field after it creates, you can know that data exists in Keel if it has a `createdAt` field.

```ts
// Wait for profile to have saved
await when(profile$.createdAt)
```

#### waitFor another table

If you have a table dependant on another table, it needs to wait for the dependant table to be created, otherwise it will fail because the relationship doesn't exist. For example you can't create messages in a chat room before that chat room exists. You can ensure the related table is created first using `waitForSet` and `createdAt`:

```ts
const rooms$ = observable(syncedKeel({
    list: queries.listRooms,
    create: mutations.createRoom,
    update: mutations.updateRoom,
}))
const roomMessages$ = observable(
    (roomId: string) => syncedKeel({
        list: queries.getRoomMessages,
        where: { roomId },
        create: (message) => mutations.createMessage({ roomId, ...message }),
        update: mutations.updateMessage,
        waitForSet: rooms$[roomId].createdAt
    })
)
```

### TODO

- options
    - transforms
- Realtime
- Persist in full example
- Handling deletes