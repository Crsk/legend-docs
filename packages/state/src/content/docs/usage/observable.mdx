---
title: Observable
sidebar:
  order: 1
---

You can put anything in an observable: primitives, deeply nested objects, arrays, functions, etc... Observables work just like normal objects so you can interact with them without any extra complication. Just call `get()` to get a value and `set(...)` to modify it.

```js
import { observable } from "@legendapp/state"

const state$ = observable({ text: "hello" })

console.log(state$.get())
// { text: 'hello' }
```

An observable's constructor can include functions or [computed](#computed)/[lookup](#lookup) observables.

```js
import { computed, observable } from "@legendapp/state"

const state$ = observable({
  fname: "",
  lname: "",
  setName: (name: string) => {
    // Create Actions by just adding a function
    const [fname, lname] = name.split(name)
    state$.assign({
      fname,
      lname,
    })
  },
  fullName: () => {
    // Set up computed observables within your state object
    // or if you prefer them elsewhere that's cool too 🤟
    return `${state$.fname.get()} ${state$.lname.get()}`
  }
})

// Call setName as a function
state$.setName('Hello there')

// Treat fullName as an observable

console.log(state$.fullName.get())
// hello there
```

> Note: In TypeScript, you need to type the return value of nested `computed` functions or the observable will have a type of `any`.

## Observable methods

### get()

Observables use [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) to expose observable functions and track changes, so an observable is a Proxy pointing to the actual data. You can use `get()` to get the actual value of any observable.

```js
const profile = { name: "Test user" }
const state$ = observable({ profile: profile, test: 0 })

// The raw value is unchanged
state$.profile.get() // { name: 'Test user' }
state$.profile === profile // ❌ false. The observable is not strictly equal to profile.
state$.profile.get() === profile // ✅ true. The raw data is exactly what was set.
```

Accessing properties through the observable will create a Proxy for every property accessed, but it will not do that while accessing the raw data. So you may want to retrieve the raw data before doing expensive computations that do not need to notify.

```js
const state$ = observable({ data: someHugeThing })
const { data } = state$.get()

// Nothing special happens when working with the raw data
processData(data)
```

Calling `get()` within a tracking context tracks the observable automatically. You can change that behavior with a parameter `true` to track only when keys are added/removed. See [observing contexts](../reactivity/#observing-contexts) for more details.

```js
state$.get(true) // Create a shallow listener
```

### peek()

`peek()` returns the raw value in the same way as `get()`, but it does not automatically track it. Use this when you don't want the component/observing context to update when the value changes.

### set()

You can use `set()` to modify the observable, at any path within it. You can even `set()` on a node that is currently undefined, and it will fill in the object tree to make it work.

```js
const state$ = observable({ text: "hi" })

// Set directly
state$.text.set("hello there")

// Set with a function relative to previous value
state$.text.set((prev) => prev + " there")

// Set will automatically fill out objects that were undefined
state$.otherKey.otherProp.set("hi")
```

### assign()

Assign is a shallow operation matching `Object.assign`. If you want a deep merge, see [mergeIntoObservable](../helper-functions/#mergeintoobservable).

```js
const state$ = observable({ text: "hi" })

// Assign
state$.assign({ text: "hi2" })
```

### delete()

Observables provide a `delete` function to delete a key from an object.

```js
const state$ = observable({ text: "hi" })

// Delete text
state$.text.delete()

// Set the whole value to undefined
state$.delete()
```


## Computed Observables

### Action Functions

Observables can have functions anywhere within them. You can use these for whatever you want, such as adding behavior to a set function. Some teams prefer to only set variables from within action functions.

```js
const state$ = observable({
    isReady: false,
    toggle: () => {
        state$.isReady.toggle()
        console.log('set to', state$.isReady.get())
    }
})
```

### Computed Functions

Any function in an observable can used a computed observable, whether it's at the root or in any child. The computed is only activated and turned into an observable when you access it as an observable.

The computed observable will re-compute itself whenever the observables it accesses with `get()` are changed.

```js
const state$ = observable({
    fname: 'Annyong',
    lname: 'Bluth',
    // A child is computed
    fullName: () => state$.fname.get() + ' ' + state$.lname.get()
})

// It acts normally when used as a function
state$.fullName()

// Accessing it as an observable activates it as a computed observable
const name = state$.fullName.get()

// A function at the root makes the observable a computed
const name$ = observable(() => state$.fname.get() + ' ' + state$.lname.get())
```

## computed

### Two-Way Computed

Use `computed` to create an observable bound to both `get` and `set` functions. This lets you pass state changes onto the target observables, so the computed observable is bound to the target(s).

```js
import { computed, observable } from "@legendapp/state"

const selected$ = observable([false, false, false])
const selectedAll$ = computed({
  // selectedAll is true when every element is selected
  get: () => selected$.every((val$) => val$.get()),

  // setting selectedAll sets the value of every element
  set: (value) => selected$.forEach((val$) => val$.set(value))
})

selectedAll$.set(true)
// selected.get() === [true, true, true]
```

### Initial value

When creating an asynchronouse observable with a Promise you may want it to have an initial default value until the promise resolves. You can use the `initial` property of `computed` to do that.

```js
import { computed } from "@legendapp/state"

const state$ = computed({
    get: () => fetch('url').then(res => res.json()),
    initial: { numUsers: 0, messages: [] }
})
```

## Advanced Computeds

### Promises

Creating an observable with a Promise or a function returning a Promise will initialize it to `undefined`, and it will be updated with the value of the Promise when it resolves.

```js
const state$ = observable(() => fetch('url').then(res => res.json()))

observe(() => {
    // Getting the value activates the observable, and updates its
    // value when it resolves.
    const data = state$.get()
    if (data) {
        ...
    }
})
```

Asynchronous observables pair very well with [when](usage/reactivity/#when) to activate the function and resolve when the observable's Promise is resolved.

```js
// Await the promise to resolve and then get the data from it
const data = await when(state$)
console.log(data)

// Wait for the promise to resolve and then get the data from it
when(state$, (data) => { console.log(data) })
```

### Linked observables

If you return an observable from a computed function, it will create a two-way link to the target observable. Any observable operations and listeners on the link will work the same as interacting with the target.

```js
const state$ = observable({
  items: ["hi", "there", "hello"],
  selectedIndex: 0,
  selectedItem: () => state$.items[state$.selectedIndex.get()],
})

state$.selectedItem.get() === "hi" // true

state$.selectedIndex.set(2)

state$.selectedItem.get() === "hello" // true
```

### Lookup table

A function with a single `string` key can be used as a lookup table, an observable object that is indexable by that key whose values are return by the function.

```ts
const state$ = observable({
  selector: 'text',
  items: { test1: { text: 'hi', othertext: 'bye' }, test2: { text: 'hello', othertext: 'goodbye' } },
  // Return a link to the [selector] property in the given item
  texts: ((key: string) => {
    return obs.items[key][obs.selector.get()]
  }),
})

// Now these reference the same thing:
state$.items.test1.text.get()
state$.texts['test1'].get()
```

### event

`event` works like an observable without a value. You can listen for changes as usual, and dispatch it manually whenever you want. This can be useful for simple events with no value, like onClosed.

```js
import { event } from "@legendapp/state"

const onClosed = event()

// Simply pass a callback to the `on` function
onClosed.on(() => { ... })

// Or use it with 'onChange' like other observables
onClosed.onChange(() => { ... })

// Dispatch the event to call listeners
onClosed.fire()
```

## Notes

### Safety

Observables are safe so that you cannot directly assign to them, which prevents accidentally overwriting state or accidentally assigning huge objects into an observable.

```js
const state$ = observable({ text: "hello", num: 10, obj: {} }, /*safe*/ true)

state$.text = "hi"
// ❌ Can't set directly

state$.text.set("hi")
// ✅ Calling set on a primitive works.

state$ = {}
// ❌ Error. This would delete the observable.

state$.obj = {}
// ❌ Error. Cannot assign to objects directly.

state$.set({ text: "hi", num: 20 })
// ✅ Calling set on an object works.

state$.assign({ text: "hello there" })
// ✅ Calling assign on an object works.

state$.text.assign({ value: "hello there" })
// ❌ Error. Cannot call assign on a primitive.
```

### undefined

Because observables track nodes [by path](../../intro/fast/#proxy-to-path) and not the underlying data, an observable points to a path within an object regardless of its actual value. So it is perfectly fine to access observables when they are currently undefined in the object.

You could to do this to set up a listener to a field whenever it becomes available.

```jsx
const state$ = observable({ user: undefined })

when(state$.user.uid, (uid) => {
  // Handle login
})
```

Or you could set a value inside an undefined object, and it will fill out the object tree to make it work.

```jsx
const state$ = observable({ user: undefined })

observe(() => {
  // This will be undefined until the full user profile is set
  console.log(`Name: ${state$.user.profile.name.get()}`)
})

state$.user.profile.name.set("Annyong")

// state$ == { user: { profile: { name: 'Annyong' } } }
```

### Arrays

Observable arrays have all of the normal array functions as you'd expect, but some are modified for observables.

All looping functions set up [shallow tracking](../reactivity#shallow-modifier) automatically, as well as provide the observable in the callback. This includes:

- every
- filter
- find
- findIndex
- forEach
- includes
- join
- map
- some

Additionally, `filter` returns an array of observables and `find` returns an observable (or undefined).

If you don't want this extra observable behavior, `get()` or `peek()` the observable to get the raw array to act on.
