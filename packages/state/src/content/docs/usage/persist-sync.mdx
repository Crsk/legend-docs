---
title: Persist and Sync
sidebar:
  order: 3
---

import Install from "shared/src/Components/Install/Install.astro"
import SelectFramework from "shared/src/Components/SelectFramework/SelectFramework.astro";
import PersistSync from "../../../Components/PersistSync/PersistSync.astro";

A primary goal of Legend-State is to make automatic persisting and syncing both easy and very robust, as it's meant to be used to power all storage and sync of complex apps - it was built as the backbone of both [Legend](https://legendapp.com) and [Bravely](https://bravely.io). It's designed to support local-first apps: any changes made while offline are persisted between sessions to be retried whenever connected. To do this, the sync system subscribes to changes on an observable, then on change goes through a multi-step flow to ensure that changes are persisted and synced.

1. Save the pending changes to local persistence
2. Save the changes to local persistence
3. Save the changes to remote persistence
4. On remote save, set any needed changes (like updatedAt) back into the observable and local persistence
5. Clear the pending changes in local persistence

## Guides

#### Which Platform?

Select React or React Native to customize this guide for your platform.

<SelectFramework onlyFirst />

### Persist data locally

Legend-State has a persistence system built in, with plugins for web and React Native. When you initialize the persistence it immediately loads and merges the changes on top of the initial value. Then any changes you make after initialization will be saved to persistence.

You can sync/persist a whole observable or any child, and there are two ways to persist observables: `synced` in the observable constructor or `syncObservable` later.

In this first example we create an observable with initial data and then use `syncObservable` to persist it.

```ts
import { observable } from "@legendapp/state"
import { syncObservable, configureObservableSync } from "@legendapp/state/sync"
import { ObservablePersistMMKV } from "@legendapp/state/persist-plugins/mmkv"

// Setup global persist configuration
configureObservableSync({
    persist: {
        plugin: ObservablePersistMMKV
    }
})

// Create an observable
const store$ = observable({
  todos: [],
});

// Persist the observable to the named key of the global persist plugin
syncObservable(store$, {
    persist: {
        name: 'persistKey',
    }
})

// Any changes made after syncObservable will be persisted
store$.todos.push({ id: 0 })
```

Alternatively we can setup the persistence in the constructor with `synced`. This example is a bit different than above, persisting only the "todos" child of the observable.

```ts
import { observable } from "@legendapp/state"
import { synced } from "@legendapp/state/sync"

// Create an observable with "todos" persisted
const store$ = observable({
    todos: synced({
        initial: [],
        persist: {
            name: 'persistKey',
        }
    })
});

// Any changes will be persisted
store$.todos.push({ id: 0 })
```

:::note
The key difference between syncObservable and synced is that syncObservable starts syncing when you call it, while synced creates a lazy computed function that activates when you `get()` it.
:::

#### Async persistence

Some persistences like IndexedDB and AsyncStorage are asynchronous, so you'll need to wait for it to load before you start reading from it. `syncState` returns an observable with load statuses that you can wait for.

```js
import { syncObservable, syncState } from '@legendapp/state/sync'

syncObservable(state$, {
    persist: {
        name: 'store' // IndexedDB table name
    }
})
const status$ = syncState(state$)
await when(status$.isPersistLoaded)
// Proceed with load
```

### Sync with a server

Legend-State makes syncing remote data very easy, while being very powerful under the hood. You can setup your sync system directly in the observable itself, so that your application code only interacts with observables, and the observables handle the sync for you.

This is a great way to isolate your syncing code in one place away from your UI, and then your UI code justs gets/sets observables.

Like with [persistence](#persist-data-locally) you can use either `syncObservable` or `synced` but we'll just focus on `synced` for this example.

```ts
import { observable, observe } from "@legendapp/state"
import { synced } from "@legendapp/state/sync"

// Create an observable with "users" synced
const store$ = observable({
    users: synced({
        initial: [],
        // When the get() promise resolves it will update the observable
        get: () => fetch('https://reqres.in/api/users').then(r => r.json()),
        // When the observable is changed it will send the changes back to the server.
        set: ({ value, changes }) => (
            // Use either the changes or the full value to send to your server
            fetch(
                'https://reqres.in/api/users',
                { method: 'POST', data: JSON.stringify(changes) }
            ),
    })
})

observe(() => {
    // The first get() activates the synced get function to fetch the data
    // observe is re-run when the data comes in
    const users = store$.users.get()
    if (users) {
        processUsers(users)
    }
})

// Any changes will be saved
store$.users.push({ id: 0, name: 'name' })
```

### Sync and persist

Now let's put both persistence and sync together. This is where Legend-State enables local-first applications that can work completely offline with eventual consistency and are resistent to bad network conditions.

All you have to do is just work with observables. That immediately updates the UI optimistically, persists changes, and syncs to your database with eventual consistency.

This example binds inputs directly to the remote data and shows you when the changes save. Try going offline and making some changes, then refresh and the changes are still there. Then go back online and watch the saved time update. You may want to open the Network panel of the dev tools to see it in action.

<PersistSync />

## API

### configureObservableSync

First you most likely want to set a global persist/sync configuration with your perferred defaults. This is optional as these settings can be set or overriden per observable.

This is a very basic example that uses localStorage for persistence web, but see [synced](#synced) for more options.

```js
import { configureObservableSync } from '@legendapp/state/sync'
import { ObservablePersistLocalStorage } from '@legendapp/state/persist-plugins/local-storage'

// Global configuration
configureObservableSync({
    persist: {
        plugin: ObservablePersistLocalStorage
    }
    retry: {
        infinite: true
    }
})
```

### synced

The easiest way to create a synced observable is to use `synced` when creating an observable to bind it to remote data and/or persist it locally. To simply set up persistence, just create `get` and `set` functions along with a `persist` option.

`synced` creates a lazy computed function which will not activate until you `get()` it. So you can set up your observables' sync/persist options and they will only activate on demand.

```js
import { observable } from '@legendapp/state'
import { synced } from '@legendapp/state/sync'

const state$ = observable(synced({
    get: () =>
        fetch('https://url.to.get').then((res) => res.json()),
    set: ({ value }) =>
        fetch('https://url.to.set', { method: 'POST', data: JSON.stringify(value) }),
    persist: {
        name: 'test',
    },
}))
```

Or a more advanced example with all of the possible options:

```js
import { observable } from '@legendapp/state'
import { synced } from '@legendapp/state/sync'
import { ObservablePersistMMKV } from '@legendapp/state/persist-plugins/mmkv'

const state$ = observable(synced({
    get: () => {
        // get is an observing function which will re-run whenever any accessed observables
        // change. You can use that for paging getting data for a specific user.
        return fetch('https://url.to.get/page=' + page.get())
                .then((res) => res.json())
    },
    set: ({ value }) => {
        // set is run when the observable changes, debounced by the debounceSet option
        fetch('https://url.to.set', { method: 'POST', data: JSON.stringify(value) })
    }
    persist: {
        // The name to be saved in the local persistence
        name: 'test',
        // Set the plugin to override the global setting
        plugin: ObservablePersistMMKV,
        options: {
            // Customize the persist plugin options
        }
    },
    // The initial value before the remote data loads or if it doesn't exist.
    initial: {
        numUsers: 0,
        messages: []
    },
    // How to update the initial value when the remote data comes in.
    // defaults to "set"
    mode: 'set' | 'assign' | 'merge' | 'append' | 'prepend',
    // The subscribe function is called once to give you an opportunity to
    // subscribe to another service to trigger refresh
    subscribe: (refresh) => {
        pusher.subscribe({ /*...*/ })
    },
    // Options for retrying in case of error. Applies to both get and set.
    retry: {
        infinite: true,
        backoff: 'exponential',
        maxDelay: 30
    },
    // "retry" will persist pending changes to be retried even if the app restarts
    offlineBehavior: false | 'retry',
    // A time to debounce changes before sending them to the server. Use this to
    // batch multiple changes together or preventing saving every keystroke.
    debounceSet: 500,
}))
```

### syncObservable

If you prefer to set up sync/persistence after the observable is already created, you can use `syncObservable` with the same options as `synced`. It's effectively the same as using `synced` with an initial value.

```js
import { observable } from '@legendapp/state'
import { synced } from '@legendapp/state/sync'

const state$ = observable({ initialKey: 'initialValue' })

syncObservable(state$, {
    get: () =>
        fetch('https://url.to.get').then((res) => res.json()),
    set: ({ value }) =>
        fetch('https://url.to.set', { method: 'POST', data: JSON.stringify(value) }),
    persist: {
        name: 'test'
    }
})
```

### syncState

Each synced observable has a `syncState` observable that you can get to check its status or do some actions.

```ts
import { observable } from '@legendapp/state'
import { synced, syncState } from '@legendapp/state/sync'

const obs$ = observable(synced({ /*...*/ }))
const state$ = syncState(obs$)
const error = state$.error.get();
const isLoaded = state$.isLoaded.get();

if (error) {
    // Handle error
} else if (!isLoaded) {
    // Do something while loading
} else {
    // Good to go
    const value = obs$.get()
}
```

The `isLoaded` and `error` properties are accessible when using `syncState` on any asynchronous Observable, but the others are created when using `synced`.

- `isPersistLoaded: boolean`: Whether it has loaded from the local persistence
- `isPersistEnabled: boolean`: Enable/disable the local persistence
- `isLoaded: boolean`: Whether the get function has returned
- `isSyncEnabled: boolean`: Enable/disable remote sync
- `lastSync: number`: Timestamp of the latest sync
- `syncCount: number`: Number of times it's synced
- `clearPersist: () => Promise<void>`: Clear the local persistence
- `sync: () => Promise<void>`: Re-run the get function
- `getPendingChanges: () => Record<string, object>`: Get all unsaved changed
- `error: Error`: The latest error

### useObservable + synced

Create a synced observable within a React component using [useObservable](../../react/react-api#useobservable).

```ts
import { synced } from '@legendapp/state/sync'
import { useObservable } from '@legendapp/state/react'

function Component() {
    const user$ = useObservable(synced({
        get: fetch('https://url.to.get').then((res) => res.json()),
        persist: {
            name: 'test'
        }
    }))
}
```

## Persist plugins

First choose and configure the storage plugin for your platform.

### Local Storage (React)

```js
import { configureObservableSync } from '@legendapp/state/sync'
import { ObservablePersistLocalStorage } from '@legendapp/state/persist-plugins/local-storage'

// Global configuration
configureObservableSync({
    persist: {
        plugin: ObservablePersistLocalStorage
    }
})
```

Then you can persist an observable with just its name in Local Storage.

```js
syncObservable(state$, {
    persist: {
        name: "documents"
    }
})
```

### IndexedDB (React)

The IndexedDB plugin can be used in two ways:

1. Persisting a dictionary where each value has an `id` field, and each value will create a row in the table
2. Persisting multiple observables to their own rows in the table with the `itemID` option

It requires some extra configuration for the database name, the table names, and the version.

IndexedDB requires changing the version whenever the tables change, so you can start with version 1 and increment the version whenever you add/change tables.

```js
import { syncObservable } from "@legendapp/state/sync"
import { ObservablePersistIndexedDB } from "@legendapp/state/persist-plugins/indexeddb"

configureObservableSync({
    persist: {
        plugin: ObservablePersistIndexedDB,
        indexedDB: {
            databaseName: "Legend",
            version: 1,
            tableNames: ["documents", "store"],
        }
    }
})

// Mode 1: Persist a dictionary
const state$ = observable({
    obj1: { id: "obj1", text: "..." },
    obj2: { id: "obj2", text: "..." },
})

syncObservable(state$, {
    persist: {
        name: "documents" // IndexedDB table name
    }
})

// Mode 2: Persist an object with itemId
const settings$ = observable({ theme: "light" })

syncObservable(settings$, {
    persist: {
        name: "store", // IndexedDB table name
        indexedDB: {
            itemID: "settings"
        }
    }
})
```

Because IndexedDB is an asynchronous API, you'll need to wait for it to load before you start reading from it. `syncObservable` returns an observable with load statuses that you can wait for.

```js
const status$ = syncObservable(state$, {
    persist: {
        name: 'store' // IndexedDB table name
    }
})
await when(status$.isPersistLoaded)
// Continue with load
```

### MMKV (RN)

First install react-native-mmkv:

<Install name="react-native-mmkv" />

Then configure it as the persist plugin.

```js
import { configureObservableSync } from '@legendapp/state/sync'
import { ObservablePersistMMKV } from '@legendapp/state/persist-plugins/mmkv'

// Global configuration
configureObservableSync({
    // Use react-native-mmkv in React Native
    persist: {
        plugin: ObservablePersistMMKV
    }
})
```

Then you can persist an observable with just a name.

```js
syncObservable(state$, {
    persist: {
        name: "documents"
    }
})
```

### AsyncStorage (RN)

Older versions of React Native have AsyncStorage built in, but newer versions may need it installed separately. Check the React Native docs for the latest guidance on that.

<Install name="@react-native-async-storage/async-storage" />

The AsyncStorage plugin needs an additional bit of global configuration, giving it the instance of AsyncStorage.

```js
import { configureObservableSync } from '@legendapp/state/sync'
import { ObservablePersistAsyncStorage } from '@legendapp/state/persist-plugins/async-storage'
import AsyncStorage from '@react-native-async-storage/async-storage';

// Global configuration
configureObservableSync({
    // Use AsyncStorage in React Native
    persist: {
        plugin: ObservablePersistAsyncStorage,
        asyncStorage: { AsyncStorage }
    }
})
```

Because AsyncStorage is an asynchronous API, you'll need to wait for it to load before you start reading from it. `syncObservable` returns an observable with load statuses that you can wait for.

```js
const status$ = syncObservable(state$, {
    persist: {
        name: 'store'
    }
})
await when(status$.isPersistLoaded)
// Continue with load
```

## Making a sync plugin

Once you're syncing multiple observables in the same way you'll likely want to create a plugin that encapsulates the specifics of your backend. The plugin just needs to return a `synced`.

This is a simple contrived example to give you an easy of what that could look like.

```ts
import { synced } from '@legendapp/state/sync'

const customSynced = ({ name }) => {
    const basePath = 'https://url/api/v1/';
    const doFetch = (path) => {
        return fetch(basePath + path).then((res) => res.json())
    }

    return synced({
        get: () => doFetch('list-' + name),
        set: ({ value }) => {
            if (value === null || value === undefined) {
                return doFetch('delete-' + name)
            } else {
                return doFetch('upsert-' + name)
            }
        },
        retry: { infinite: true },
        persist: {
            name
        },
        waitFor: isAuthed$,
        subscribe: ({ refresh }) => {
            // Subscribe to realtime service
        },
    });
}
```

TODO: More details

## persistObservable (Deprecated)

`persistObservable` can be used to automatically persist an observable, both locally and remotely. It will be saved whenever you change anything anywhere within the observable, and the observable will be filled with the local state right after calling `persistObservable`.

The second parameter to `persistObservable` provides some options:

- `local`: A unique name for this observable in storage or options to configure it
- `pluginLocal`: The local persistence plugin to use. This defaults to use the globally configured pluginLocal.
- `remote`: Options to configure remote persistence
- `pluginRemote`: The persistence plugin to use. This defaults to use the globally configured pluginRemote.

`persistObservable` returns the observable with an additional `state` child that can be used to check it's loading state.

First you most likely want to set a global configuration for which plugins to use, though it can also be configured per observable.