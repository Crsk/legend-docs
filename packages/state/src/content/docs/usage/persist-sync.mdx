---
title: Persist and Sync
sidebar:
  order: 3
---

import Install from "shared/src/Components/Install/Install.astro"

A primary goal of Legend-State is to make automatic persisting and syncing both easy and very robust, as it's meant to be used to power all storage and sync of complex apps - it was built as the backbone of both [Legend](https://legendapp.com) and [Bravely](https://bravely.io). It's designed to support local-first apps: any changes made while offline can be persisted between sessions to be retried in a future session when connected. To do this, the sync system simply subscribes to changes on an observable, then on change goes through a multi-step flow to ensure that changes are persisted.

1. Save the pending changes to the metadata table in local persistence
2. Save the changes to local persistence
3. Save the changes to remote persistence
4. On remote save, set any needed changes (like dateModified) back into the observable
5. Clear the pending changes in the metadata table in local persistence

## Configuration

First you most likely want to set a global persist/sync configuration with your perferred defaults. This is optional as these settings can be set or overriden per observable.

This is a very basic example that uses localStorage for persistence web, but see the [configuring](#configuring) section for more options.

```js
import { configureObservableSync } from '@legendapp/state/sync'
import { ObservablePersistLocalStorage } from '@legendapp/state/persist-plugins/local-storage'

// Global configuration
configureObservableSync({
    persist: {
        plugin: ObservablePersistLocalStorage
    }
    retry: {
        infinite: true
    }
})
```

## synced

The easiest way to create a synced observable is to use `synced` when creating an observable to bind it to remote data and/or persist it locally. To simply set up persistence, just create `get` and `set` functions along with a `persist` option.

```js
import { observable } from '@legendapp/state'
import { synced } from '@legendapp/state/sync'

const state$ = observable(synced({
    get: () =>
        fetch('https://url.to.get').then((res) => res.json()),
    set: ({ value }) =>
        fetch('https://url.to.set', { method: 'POST', data: JSON.stringify(value) }),
    persist: {
        name: 'test',
    },
}))
```

Or a more advanced example with all of the possible options:

```js
import { observable } from '@legendapp/state'
import { synced } from '@legendapp/state/sync'
import { ObservablePersistMMKV } from '@legendapp/state/persist-plugins/mmkv'

const state$ = observable(synced({
    get: () => {
        // get is an observing function which will re-run whenever any accessed observables
        // change. You can use that for paging getting data for a specific user.
        return fetch('https://url.to.get/page=' + page.get())
                .then((res) => res.json())
    },
    set: ({ value }) => {
        // set is run when the observable changes, debounced by the debounceSet option
        fetch('https://url.to.set', { method: 'POST', data: JSON.stringify(value) })
    }
    persist: {
        // The name to be saved in the local persistence
        name: 'test',
        // Set the plugin to override the global setting
        plugin: ObservablePersistMMKV,
        options: {
            // Customize the persist plugin options
        }
    },
    // The initial value before the remote data loads or if it doesn't exist.
    initial: {
        numUsers: 0,
        messages: []
    },
    // How to update the initial value when the remote data comes in.
    // defaults to "set"
    mode: 'set' | 'assign' | 'merge' | 'append' | 'prepend',
    // The subscribe function is called once to give you an opportunity to
    // subscribe to another service to trigger refresh
    subscribe: (refresh) => {
        pusher.subscribe({ /*...*/ })
    },
    // Options for retrying in case of error. Applies to both get and set.
    retry: {
        infinite: true,
        backoff: 'exponential',
        maxDelay: 30
    },
    // "retry" will persist pending changes to be retried even if the app restarts
    offlineBehavior: false | 'retry';
    // A time to debounce changes before sending them to the server. Use this to
    // batch multiple changes together or preventing saving every keystroke.
    debounceSet: number;
}))
```

## syncObservable

If you prefer to set up sync/persistence after the observable is already created, you can use `syncObservable` with the same options as `synced`. It's effectively the same as using `synced` with an initial value.

```js
import { observable } from '@legendapp/state'
import { synced } from '@legendapp/state/sync'

const state$ = observable({ initialKey: 'initialValue' })

syncObservable(state$, {
    get: () =>
        fetch('https://url.to.get').then((res) => res.json()),
    set: ({ value }) =>
        fetch('https://url.to.set', { method: 'POST', data: JSON.stringify(value) }),
    persist: {
        name: 'test'
    }
})
```


## syncState

Each synced observable has a `syncState` observable that you can get to check its status or do some actions.

```ts
import { observable } from '@legendapp/state'
import { synced, syncState } from '@legendapp/state/sync'

const obs$ = observable(synced({ /*...*/ }))
const state$ = syncState(obs$)
const error = state$.error.get();
const isLoaded = state$.isLoaded.get();

if (error) {
    // Handle error
} else if (!isLoaded) {
    // Do something while loading
} else {
    // Good to go
    const value = obs$.get()
}
```

The `isLoaded` and `error` properties are accessible when using `syncState` on any asynchronous Observable, but the others are created when using `synced`.

- `isLoadedLocal: boolean`: Whether it has loaded from the local persistence
- `isEnabledLocal: boolean`: Enable/disable the local persistence
- `isLoaded: boolean`: Whether the get function has returned
- `isEnabledRemote: boolean`: Enable/disable remote sync
- `lastSync: number`: Timestamp of the latest sync
- `syncCount: number`: Number of times it's synced
- `clearPersist: () => Promise<void>`: Clear the local persistence
- `sync: () => Promise<void>`: Re-run the get function
- `getPendingChanges: () => Record<string, object>`: Get all unsaved changed
- `error: Error`: The latest error

### React hook

Create a synced observable within a React component using [useObservable](../../react/react-api#useobservable).

```ts
import { synced } from '@legendapp/state/sync'
import { useObservable } from '@legendapp/state/react'

function Component() {
    const user$ = useObservable(synced({
        get: fetch('https://url.to.get').then((res) => res.json()),
        persist: {
            name: 'test'
        }
    }))
}
```

## Persist plugins

First choose and configure the storage plugin for your platform.

##### Local Storage (React)

```js
import { configureObservableSync } from '@legendapp/state/sync'
import { ObservablePersistLocalStorage } from '@legendapp/state/persist-plugins/local-storage'

// Global configuration
configureObservableSync({
    persist: {
        plugin: ObservablePersistLocalStorage
    }
})
```

##### IndexedDB (React)

```js
import { configureObservableSync } from '@legendapp/state/sync'
import { ObservablePersistIndexedDB } from '@legendapp/state/persist-plugins/indexeddb'

// Global configuration
configureObservableSync({
    persist: {
        plugin: ObservablePersistIndexedDB
    }
})
```

##### MMKV (React Native)
```js
import { configureObservableSync } from '@legendapp/state/sync'
import { ObservablePersistMMKV } from '@legendapp/state/persist-plugins/mmkv'

// Global configuration
configureObservableSync({
    // Use react-native-mmkv in React Native
    persist: {
        plugin: ObservablePersistMMKV
    }
})
```

##### AsyncStorage (React Native)
```js
import { configureObservableSync } from '@legendapp/state/sync'
import { ObservablePersistAsyncStorage } from '@legendapp/state/persist-plugins/async-storage'

// Global configuration
configureObservableSync({
    // Use AsyncStorage in React Native
    persist: {
        plugin: ObservablePersistAsyncStorage,
        asyncStorage: {
            // The AsyncStorage plugin needs to be given the implementation of AsyncStorage
            AsyncStorage
        }
    }
})
```

### IndexedDB

The IndexedDB plugin can be used in two ways:

1. Persisting a dictionary where each value has an `id` field, and each value will create a row in the table
2. Persisting multiple observables to their own rows in the table with the `itemID` option

It requires some extra configuration for the database name, the table names, and the version.

IndexedDB requires changing the version whenever the tables change, so you can start with version 1 and increment the version whenever you add/change tables.

```js
import { syncObservable } from "@legendapp/state/sync"
import { ObservablePersistIndexedDB } from "@legendapp/state/persist-plugins/indexeddb"

configureObservableSync({
    persist: {
        plugin: ObservablePersistIndexedDB,
        indexedDB: {
            databaseName: "Legend",
            version: 1,
            tableNames: ["documents", "store"],
        }
    }
})

// Mode 1: Persist a dictionary
const state$ = observable({
    obj1: { id: "obj1", text: "..." },
    obj2: { id: "obj2", text: "..." },
})

syncObservable(state$, {
    persist: {
        name: "documents" // IndexedDB table name
    }
})

// Mode 2: Persist an object with itemId
const settings$ = observable({ theme: "light" })

syncObservable(settings$, {
    persist: {
        name: "store", // IndexedDB table name
        indexedDB: {
            itemID: "settings"
        }
    }
})
```

Because IndexedDB is an asynchronous API, you'll need to wait for it to load before you start reading from it. `syncObservable` returns an Observable with load statuses that you can wait for.

```js
const status$ = syncObservable(state$, {
    persist: {
        name: 'store' // IndexedDB table name
    }
})
await when(status$.isLoadedLocal)
...
```

### React Native

If you are on React Native you will need to install `react-native-mmkv` or `@react-native-async-storage/async-storage`, depending on which one you choose to use.

<Install name="react-native-mmkv" />

<Install name="@react-native-async-storage/async-storage" />

## Making a sync plugin

Once you're syncing multiple observables in the same way you'll likely want to create a plugin that encapsulates the specifics of your backend. The plugin just needs to return a `synced`.

This is a simple contrived example to give you an easy of what that could look like.

```ts
import { synced } from '@legendapp/state/sync'

const customSynced = ({ name }) => {
    const basePath = 'https://url/api/v1/';
    const doFetch = (path) => {
        return fetch(basePath + path).then((res) => res.json())
    }

    return synced({
        get: () => doFetch('list-' + name),
        set: ({ value }) => {
            if (value === null || value === undefined) {
                return doFetch('delete-' + name)
            } else {
                return doFetch('upsert-' + name)
            }
        },
        retry: { infinite: true },
        persist: {
            name
        },
        waitFor: isAuthed$,
        subscribe: ({ refresh }) => {
            // Subscribe to realtime service
        },
    });
}
```

TODO: More details

## persistObservable (Deprecated)

`persistObservable` can be used to automatically persist an observable, both locally and remotely. It will be saved whenever you change anything anywhere within the observable, and the observable will be filled with the local state right after calling `persistObservable`.

The second parameter to `persistObservable` provides some options:

- `local`: A unique name for this observable in storage or options to configure it
- `pluginLocal`: The local persistence plugin to use. This defaults to use the globally configured pluginLocal.
- `remote`: Options to configure remote persistence
- `pluginRemote`: The persistence plugin to use. This defaults to use the globally configured pluginRemote.

`persistObservable` returns the observable with an additional `state` child that can be used to check it's loading state.

First you most likely want to set a global configuration for which plugins to use, though it can also be configured per observable.